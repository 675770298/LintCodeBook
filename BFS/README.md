##BFS

- Queue + HashMap -> BFS
- 从图上一个点走到其他所有点
- 在图上计算两点之间的最短距离

更细一点的划分的话，这一类的问题还可以分为：
```
层级遍历 Level Order Traversal
由点及面 Connected Component
拓扑排序 Topological Sorting
```
##图

有很多种方法可以存储一个图，最常用的莫过于：
- 邻接矩阵
- 邻接表

而邻接矩阵因为耗费空间过大，我们通常在工程中都是使用邻接表作为图的存储结构。

###邻接矩阵
```
邻接矩阵 Adjacent Matrix

[
  [1,0,0,1],
  [0,1,1,0],
  [0,1,1,0],
  [1,0,0,1]
]
```
```
例如上图表示0号点和3号点有连边。1号点和2号店有连边。
当然，每个点和自己也是默认有连边的。
图中的 0 表示不连通，1 表示连通。
我们也可以用一个更具体的整数值来表示连边的长度。
邻接矩阵我们可以直接用一个二维数组表示，如int[][] matrix;。
这种数据结构因为耗费 O(n^2) 的空间，所以在稀疏图上浪费很大，因此并不常用。
```
###邻接表
```
邻接表 (Adjacent List)

[
  [1],
  [0,2,3],
  [1],
  [1]
]
```
```
这个图表示 0 和 1 之间有连边，1 和 2 之间有连边，1 和 3 之间有连边。
即每个点上存储自己有哪些邻居（有哪些连通的点）。
这种方式下，空间耗费和边数成正比，
可以记做 O(m)，m代表边数。m最坏情况下虽然也是 O(n^2)，
但是邻接表的存储方式大部分情况下会比邻接矩阵更省空间。
```

```
可以用自定义的类来实现邻接表

class DirectedGraphNode {
    int label;
    List<DirectedGraphNode> neighbors;
    ...
}

也可以用也可以使用 HashMap 和 HashSet 搭配的方式来存储邻接表

Map<T, Set<T>> = new HashMap<Integer, HashSet<Integer>>();
```
