##递归

##内存

    我们通常所说的内存空间，包含了两个部分：栈空间（Stack space）和堆空间（Heap space）

    当一个程序在执行的时候，操作系统为了让进程可以使用一些固定的不被其他进程侵占的空间用于进行函数调用，递归等操作，会开辟一个固定大小的空间（比如 8M）给一个进程使用。
    这个空间不会太大，否则内存的利用率就很低。这个空间就是我们说的栈空间，Stack space。

    我们通常所说的栈溢出（Stack Overflow）是指在函数调用，或者递归调用的时候，开辟了过多的内存，超过了操作系统余留的那个很小的固定空间导致的。
    那么哪些部分的空间会被纳入栈空间呢？栈空间主要包含如下几个部分：

    new 出来的就放在堆空间，其他都是栈空间
    
###内存溢出   

太深的递归会内存溢出
首先，函数本身也是在内存中占空间的，主要用于存储传递的参数，以及调用代码的返回地址。
函数的调用，会在内存的栈空间中开辟新空间，来存放子函数。递归函数更是会不断占用栈空间，例如该阶乘函数，展开到最后n=1时，内存中会存在factorial(100), factorial(99), factorial(98) ... factorial(1)这些函数，它们从栈底向栈顶方向不断扩展。
当递归过深时，栈空间会被耗尽，这时就无法开辟新的函数，会报出stack overflow这样的错误。
所以，在考虑空间复杂度时，递归函数的深度也是要考虑进去的。

Follow up：
尾递归：若递归函数中，递归调用是整个函数体中最后的语句，且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。（上例factorial函数满足前者，但不满足后者，故不是尾递归函数）
尾递归函数的特点是：在递归展开后该函数不再做任何操作，这意味着该函数可以不等子函数执行完，自己直接销毁，这样就不再占用内存。一个递归深度O(n)O(n)的尾递归函数，可以做到只占用O(1)O(1)空间。这极大的优化了栈空间的利用。
但要注意，这种内存优化是由编译器决定是否要采取的，不过大多数现代的编译器会利用这种特点自动生成优化的代码。在实际工作当中，尽量写尾递归函数，是很好的习惯。
而在算法题当中，计算空间复杂度时，建议还是老老实实地算空间复杂度了，尾递归这种优化提一下也是可以，但别太在意。

###1.递归的定义
###2.递归的拆解
###3.递归的出口

```
//递归版本，会超时
//超时的原因是过量的重复计算，每次都要计算f(n-1) f(n-2)
//所以要么把这些计算过的值存起来，要么用循环替代此递归
public class Solution {
    /*
     * @param : an integer
     * @return: an ineger f(n)
     */
     //1.递归的定义
    public int fibonacci(int n) {
        // write your code here
        //3.递归的出口
        if (n == 1) {
            return 0;
        }
        
        if (n == 2) {
            return 1;
        }
        //2.递归的拆解
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
};
```
